import { NextResponse } from 'next/server';

export async function GET(request: Request, { params }: { params: Promise<{ cveId: string }> }) {
  const { cveId } = await params;

  if (!cveId) {
    return NextResponse.json({ error: 'CVE ID is required' }, { status: 400 });
  }

  try {
    const baseUrl = request.nextUrl.clone().origin;
    const response = await fetch(`${baseUrl}/api/enriched-vulnerabilities`);
    const enrichedData = await response.json();

    const cve = enrichedData.vulnerabilities.find(v => v.id === cveId);

    if (!cve) {
      return NextResponse.json({ error: 'CVE not found' }, { status: 404 });
    }

    const nodes = [];
    const edges = [];
    let yPos = 100;

    // CVE Node
    nodes.push({ id: cve.id, data: { label: cve.id }, position: { x: 400, y: 50 }, style: { background: '#2563eb', color: 'white' }, type: 'input' });

    // CVSS Nodes
    if (cve.metrics?.cvssMetricV31?.[0]) {
      const cvss = cve.metrics.cvssMetricV31[0].cvssData;
      const cvssNodeId = `${cve.id}-cvss`;
      const severityColor = cvss.baseSeverity === 'CRITICAL' ? '#dc2626' : cvss.baseSeverity === 'HIGH' ? '#f97316' : '#facc15';
      nodes.push({ id: cvssNodeId, data: { label: `CVSS V3.1: ${cvss.baseScore} (${cvss.baseSeverity})` }, position: { x: 150, y: yPos }, style: { background: severityColor, color: 'white' } });
      edges.push({ id: `${cve.id}-${cvssNodeId}`, source: cve.id, target: cvssNodeId });

      const metrics = {
        'Attack Vector': cvss.attackVector,
        'Attack Complexity': cvss.attackComplexity,
        'Privileges Required': cvss.privilegesRequired,
        'User Interaction': cvss.userInteraction,
        'Confidentiality': cvss.confidentialityImpact,
        'Integrity': cvss.integrityImpact,
        'Availability': cvss.availabilityImpact,
      };

      let metricYPos = yPos + 100;
      for (const [key, value] of Object.entries(metrics)) {
        const metricId = `${cvssNodeId}-${key}`;
        nodes.push({ id: metricId, data: { label: `${key}: ${value}` }, position: { x: 0, y: metricYPos }, style: { background: '#4b5563', color: 'white' } });
        edges.push({ id: `${cvssNodeId}-${metricId}`, source: cvssNodeId, target: metricId });
        metricYPos += 50;
      }
      yPos = metricYPos;
    }

    // CWE Node
    if (cve.weaknesses?.[0]) {
      const cweId = cve.weaknesses[0].description[0].value;
      const cweResponse = await fetch(`${baseUrl}/api/cwe/${cweId}`);
      const cweData = await cweResponse.json();
      const cweDetails = cweData.Weaknesses?.[0];
      const cweNodeId = `${cve.id}-cwe`;
      nodes.push({ id: cweNodeId, data: { label: `${cweId}: ${cweDetails.Name}` }, position: { x: 650, y: 100 }, style: { background: '#16a34a', color: 'white' } });
      edges.push({ id: `${cve.id}-${cweNodeId}`, source: cve.id, target: cweNodeId });

      if(cweDetails) {
        const cweMetrics = {
            'Abstraction': cweDetails.Abstraction,
            'Structure': cweDetails.Structure,
            'Status': cweDetails.Status,
            'Likelihood Of Exploit': cweDetails.LikelihoodOfExploit
        };
        let cweMetricYPos = 200;
        for (const [key, value] of Object.entries(cweMetrics)) {
            if (value) {
                const metricId = `${cweNodeId}-${key}`;
                nodes.push({ id: metricId, data: { label: `${key}: ${value}` }, position: { x: 800, y: cweMetricYPos }, style: { background: '#15803d', color: 'white' } });
                edges.push({ id: `${cweNodeId}-${metricId}`, source: cweNodeId, target: metricId });
                cweMetricYPos += 50;
            }
        }
      }

      yPos = Math.max(yPos, 150);
    }

    // MITRE ATT&CK Nodes
    if (cve.mitreAttack && cve.mitreAttack.length > 0) {
        const tacticYPos = yPos + 100;
        const tactics = {};
        cve.mitreAttack.forEach((technique: { tactic: string | number; }) => {
            // @ts-ignore
            if (!tactics[technique.tactic]) {
                // @ts-ignore
                tactics[technique.tactic] = [];
            }
            // @ts-ignore
            tactics[technique.tactic].push(technique);
        });

        let tacticXPos = 400;
        const tacticColors = ['#9333ea', '#db2777', '#f59e0b', '#10b981', '#3b82f6'];
        let colorIndex = 0;

        for (const tactic in tactics) {
            const tacticNodeId = `${cve.id}-tactic-${tactic}`;
            const tacticColor = tacticColors[colorIndex % tacticColors.length];
            colorIndex++;
            nodes.push({ id: tacticNodeId, data: { label: tactic }, position: { x: tacticXPos, y: tacticYPos }, style: { background: tacticColor, color: 'white' } });
            edges.push({ id: `${cve.id}-${tacticNodeId}`, source: cve.id, target: tacticNodeId });

            let techniqueYPos = tacticYPos + 100;
            tactics[tactic].forEach(technique => {
                const techniqueNodeId = `${cve.id}-mitre-${technique.id}`;
                nodes.push({ id: techniqueNodeId, data: { label: `${technique.id.split('-')[0]}: ${technique.name}` }, position: { x: tacticXPos, y: techniqueYPos }, style: { background: tacticColor, color: 'white' } });
                edges.push({ id: `${tacticNodeId}-${techniqueNodeId}`, source: tacticNodeId, target: techniqueNodeId });

                const detectionNodeId = `${techniqueNodeId}-detection`;
                nodes.push({ id: detectionNodeId, data: { label: `Detection: ${technique.detectionName}` }, position: { x: tacticXPos + 200, y: techniqueYPos }, style: { background: '#fde047', color: 'black' } });
                edges.push({ id: `${techniqueNodeId}-${detectionNodeId}`, source: techniqueNodeId, target: detectionNodeId });

                const mitigationNodeId = `${techniqueNodeId}-mitigation`;
                nodes.push({ id: mitigationNodeId, data: { label: `Mitigation: ${technique.description}` }, position: { x: tacticXPos + 200, y: techniqueYPos + 50 }, style: { background: '#a7f3d0', color: 'black' } });
                edges.push({ id: `${techniqueNodeId}-${mitigationNodeId}`, source: techniqueNodeId, target: mitigationNodeId });

                techniqueYPos += 100;
            });
            tacticXPos += 400;
        }
        yPos = Math.max(yPos, tacticYPos + 50 * cve.mitreAttack.length);
    }

    // Red Hat Advisories
    if (cve.redhatAdvisories && cve.redhatAdvisories.length > 0) {
        let advisoryYPos = yPos + 100;
        cve.redhatAdvisories.forEach(advisory => {
            const advisoryNodeId = `${cve.id}-rhsa-${advisory.id}`;
            nodes.push({ id: advisoryNodeId, data: { label: `${advisory.id}: ${advisory.severity}` }, position: { x: 150, y: advisoryYPos }, style: { background: '#ef4444', color: 'white' } });
            edges.push({ id: `${cve.id}-${advisoryNodeId}`, source: cve.id, target: advisoryNodeId });
            advisoryYPos += 50;
        });
        yPos = advisoryYPos;
    }

    // AbuseIPDB
    if (cve.abuseIpdbInfo && cve.abuseIpdbInfo.length > 0) {
        let ipYPos = yPos + 100;
        cve.abuseIpdbInfo.forEach(ip => {
            const ipNodeId = `${cve.id}-ip-${ip.ipAddress}`;
            nodes.push({ id: ipNodeId, data: { label: `${ip.ipAddress} (${ip.abuseConfidenceScore}%)` }, position: { x: 650, y: ipYPos }, style: { background: '#f97316', color: 'white' } });
            edges.push({ id: `${cve.id}-${ipNodeId}`, source: cve.id, target: ipNodeId });
            ipYPos += 50;
        });
    }

    // IoC Nodes
    const iocRegex = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b|([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.){1,}[a-zA-Z]{2,}|[a-fA-F0-9]{32}|[a-fA-F0-9]{40}|[a-fA-F0-9]{64}/g;
    const iocMatches = cve.descriptions?.map(d => d.value).join(' ').match(iocRegex) || [];
    
    if (iocMatches.length > 0) {
        let iocYPos = yPos + 100;
        for (const ioc of iocMatches) {
            const threatFoxResponse = await fetch(`${baseUrl}/api/threatfox`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ ioc })
            });
            const threatFoxData = await threatFoxResponse.json();

            if (threatFoxData.query_status === 'ok' && threatFoxData.data.length > 0) {
                const iocData = threatFoxData.data[0];
                const iocNodeId = `${cve.id}-ioc-${iocData.id}`;
                nodes.push({ id: iocNodeId, data: { label: `IoC: ${iocData.ioc} (${iocData.threat_type})` }, position: { x: 650, y: iocYPos }, style: { background: '#f97316', color: 'white' } });
                edges.push({ id: `${cve.id}-${iocNodeId}`, source: cve.id, target: iocNodeId });
                iocYPos += 50;
            }
        }
    }

    return NextResponse.json({ nodes, edges });

  } catch (error) {
    console.error(`Error fetching graph data for ${cveId}:`, error);
    return NextResponse.json({ error: 'Failed to fetch graph data' }, { status: 500 });
  }
}